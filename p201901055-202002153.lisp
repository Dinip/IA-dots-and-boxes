(in-package :p201901055-202002153)

(defvar *best-alfa-value* most-negative-fixnum)
(defvar *estado* nil)

(defun jogar (estado tempo)
  (setq *estado* nil)
  (setq *best-alfa-value* most-negative-fixnum)
  (alfabeta (cria-no estado 0) 4 1 tempo)
  (no-estado *estado*)
)

(defun get-arcos-horizontais (tabuleiro)
	(first tabuleiro)
)

(defun get-arcos-verticais (tabuleiro)
	(second tabuleiro)
)

(defun get-arco-na-posicao (posicao-arco posicao-elemento lista-arcos)
	(cond ((null lista-arcos) nil)
        (t (nth (- posicao-elemento 1) (nth (- posicao-arco 1) lista-arcos)))
  )
)

(defun cria-no (estado &optional (depth 0))
  (list estado depth)
)

(defun no-estado (no)
  (car no)
)

(defun no-tabuleiro (no)
  (car (car no))
)

(defun no-caixas-fechadas (no)
  (second (car no))
)

(defun no-profundidade (no)
  (second no)
)

(defun operators ()
 (list 'arco-horizontal 'arco-vertical)
)

(defun criar-estado (tabuleiro caixas-fechadas)
  (list tabuleiro caixas-fechadas)
)

(defun incrementar-caixas-player (player dif-novas-caixas valor-caixas-antigo)
  (cond ((= player 1) (list (+ dif-novas-caixas (first valor-caixas-antigo)) (second valor-caixas-antigo)))
        ((= player 2) (list (first valor-caixas-antigo) (+ dif-novas-caixas (second valor-caixas-antigo))))
  )
)

(defun substituir (indice lista-arcos &optional (player 1)) 
  (cond ((null lista-arcos) nil)
        ((= indice 1) (cons player (cdr lista-arcos)))
        (t (cons (car lista-arcos) (substituir (- indice 1) (cdr lista-arcos) player)))
  )
)

(defun arco-na-posicao (posicao-arco posicao-elemento lista-arcos &optional (player 1))
  (cond ((null lista-arcos) nil)
    		((= posicao-arco 1) (cons (substituir posicao-elemento (car lista-arcos) player) (cdr lista-arcos)))
    		(t (cons (car lista-arcos) (arco-na-posicao (- posicao-arco 1) posicao-elemento (cdr lista-arcos))))
  )
)

(defun arco-horizontal (indice1 indice2 tabuleiro &optional (player 1)) 
    (cond ((null tabuleiro) nil)
        	((or (< (length (car tabuleiro)) indice1) (>= 0 indice1) ) nil)
        	((or (< (length (caar tabuleiro)) indice2) (>= 0 indice2) ) nil)
        	((= (get-arco-na-posicao indice1 indice2 (get-arcos-horizontais tabuleiro)) 1) nil)
        	(t (cons (arco-na-posicao indice1 indice2 (get-arcos-horizontais tabuleiro) player) (cdr tabuleiro)))
    )
)

(defun arco-vertical (indice1 indice2 tabuleiro &optional (player 1)) 
		(cond ((null tabuleiro) nil)
					((or (< (length (second tabuleiro)) indice1) (>= 0 indice1) ) nil)
					((or (< (length (cadr tabuleiro)) indice2) (>= 0 indice2) ) nil)
					((= (get-arco-na-posicao indice1 indice2 (get-arcos-verticais tabuleiro)) 1) nil)
					(t (list (car tabuleiro) (arco-na-posicao indice1 indice2 (get-arcos-verticais tabuleiro) player)))
		)
)

(defun get-indices-arcos-vazios (lista-arcos &optional (indice 1))
	(cond ((null lista-arcos) nil)
				(t (append (mapcar #'(lambda (x) (list indice x)) (get-indices-arcos-vazios-aux (car lista-arcos) 1)) (get-indices-arcos-vazios (cdr lista-arcos) (+ indice 1))))
	)
)

(defun get-indices-arcos-vazios-aux (lista-arcos indice)
	(cond ((null lista-arcos) nil)
				((not (= (car lista-arcos) 0)) (get-indices-arcos-vazios-aux (cdr lista-arcos) (+ indice 1)))
				(t (cons indice (get-indices-arcos-vazios-aux (cdr lista-arcos) (+ indice 1))))
	)
)

(defun tabuleiro-preenchidop (no)
  (= (apply #'+ (no-caixas-fechadas no)) 30)
)

(defun novo-sucessor (no operador op-params jogador caixas-antes &optional (inc-depth 1))
  (let* ((estado-sucessor (funcall operador (first op-params) (second op-params) (no-tabuleiro no) jogador)) (caixas-dif (- (closed-boxes estado-sucessor) caixas-antes)))
    (cria-no (criar-estado estado-sucessor (incrementar-caixas-player jogador caixas-dif (no-caixas-fechadas no))) (+ (no-profundidade no) inc-depth))
  )
)

(defun sucessores (no jogador &optional (inc-depth 1))
  (if (tabuleiro-preenchidop no)
    (list no)
    (let* ((numero-caixas-no (apply #'+ (no-caixas-fechadas no)))
           (nos-sucessores 
            (append
    	        (mapcar (lambda (xycoords) (novo-sucessor no (first (operators)) xycoords jogador numero-caixas-no inc-depth))
                (get-indices-arcos-vazios (get-arcos-horizontais (no-tabuleiro no))) ;;lista de indices de arcos horizontais vazios
              )
    	        (mapcar (lambda (xycoords) (novo-sucessor no (second (operators)) xycoords jogador numero-caixas-no inc-depth)) 
                (get-indices-arcos-vazios (get-arcos-verticais (no-tabuleiro no))) ;;lista de indices de arcos verticais vazios
              )
            )
           )
          )
          (remove-duplicates (play-again numero-caixas-no nos-sucessores jogador) :test #'equal)
    )
  )
)

(defun play-again (caixas-atual nos-sucessores jogador)
  (cond ((null nos-sucessores) nil)
        ((> (apply #'+ (no-caixas-fechadas (car nos-sucessores))) caixas-atual) (append (sucessores (car nos-sucessores) jogador 0) (play-again caixas-atual (cdr nos-sucessores) jogador)))
        (t (cons (car nos-sucessores) (play-again caixas-atual (cdr nos-sucessores) jogador)))
  )
)

(defun closed-boxes (table &optional (row 1) (col 1))
  (cond ((null table) nil)
        ((>= row (length (get-arcos-horizontais table))) 0)
        ((>= col (length (get-arcos-verticais table))) (closed-boxes table (+ row 1) 1))
        ((and (not (= (get-arco-na-posicao row col (get-arcos-horizontais table)) 0))
              (not (= (get-arco-na-posicao (+ row 1) col (get-arcos-horizontais table)) 0))
              (not (= (get-arco-na-posicao col row (get-arcos-verticais table)) 0))
              (not (= (get-arco-na-posicao (+ col 1) row (get-arcos-verticais table)) 0))
          )
         (+ 1 (closed-boxes table row (+ col 1)))
        )
        (t (closed-boxes table row (+ col 1)))
  )
)

;; contar quantas "caixas" estao a 1 arco de serem fechadas
;; 3 lados completos e ignora as que ja estao fechadas
;; que tecnicamente tambem tem 3 lados completos
(defun 3-side-boxes (table &optional (row 1) (col 1))
  (cond ((null table) nil)
        ((>= row (length (get-arcos-horizontais table))) 0)
        ((>= col (length (get-arcos-verticais table))) (3-side-boxes table (+ row 1) 1))
        (
          (and
            (or
              (and (not (= (get-arco-na-posicao row col (get-arcos-horizontais table)) 0))
                   (not (= (get-arco-na-posicao (+ row 1) col (get-arcos-horizontais table)) 0))
                   (not (= (get-arco-na-posicao col row (get-arcos-verticais table)) 0))
              )
              (and (not (= (get-arco-na-posicao row col (get-arcos-horizontais table)) 0))
                   (not (= (get-arco-na-posicao (+ row 1) col (get-arcos-horizontais table)) 0))
                   (not (= (get-arco-na-posicao (+ col 1) row (get-arcos-verticais table)) 0))
              )
              (and (not (= (get-arco-na-posicao row col (get-arcos-horizontais table)) 0))
                   (not (= (get-arco-na-posicao col row (get-arcos-verticais table)) 0))
                   (not (= (get-arco-na-posicao (+ col 1) row (get-arcos-verticais table)) 0))
              )
              (and (not (= (get-arco-na-posicao (+ row 1) col (get-arcos-horizontais table)) 0))
                   (not (= (get-arco-na-posicao col row (get-arcos-verticais table)) 0))
                   (not (= (get-arco-na-posicao (+ col 1) row (get-arcos-verticais table)) 0))
              )
            )
            (not 
              (and 
                (not (= (get-arco-na-posicao row col (get-arcos-horizontais table)) 0))
                (not (= (get-arco-na-posicao (+ row 1) col (get-arcos-horizontais table)) 0))
                (not (= (get-arco-na-posicao col row (get-arcos-verticais table)) 0))
                (not (= (get-arco-na-posicao (+ col 1) row (get-arcos-verticais table)) 0))
              )
            )
          )
         (+ 1 (3-side-boxes table row (+ col 1)))
        )
        (t (3-side-boxes table row (+ col 1)))
  )
)

(defun trocar-jogador (jogador)
  (cond ((= jogador 1) 2)
        (t 1)
  )
)

(defun caixas-fechadas-jogador (jogador no)
  (cond ((= jogador 1) (first (no-caixas-fechadas no)))
        (t (second (no-caixas-fechadas no)))
  )
)

(defun avaliar (no)
  (- (caixas-fechadas-jogador 1 no) (caixas-fechadas-jogador 2 no))
)

(defun avaliar-v2 (no)
  (- (- (* (caixas-fechadas-jogador 1 no) 10) (* (3-side-boxes (no-tabuleiro no)) 5)) (* (caixas-fechadas-jogador 2 no) 10))
)

(defun guardar-solucao (no value)
  (if (> value *best-alfa-value*)
    (progn 
      (setq *best-alfa-value* value)
      (setq *estado* no)
    )
  )
)

(defun alfabeta (no &optional (max-depth 2) (jogador 1) (max-time 5000) (alfa most-negative-fixnum) (beta most-positive-fixnum) (initial-time (get-internal-real-time)))
  (cond (
          (OR (tabuleiro-preenchidop no) 
		          (= (no-profundidade no) max-depth)
              (>= (get-internal-real-time) (+ initial-time (* max-time 0.9)))
              (null no)
          ) (avaliar-v2 no)
        )
        (t
          (let ((nos-sucessores (remove-duplicates (sucessores no jogador) :test #'equal)))
            (cond ((= (mod (no-profundidade no) 2) 0) (alfabeta-max (sort nos-sucessores #'> :key #'avaliar-v2) max-depth jogador max-time alfa beta initial-time))
                   (t (alfabeta-min (sort nos-sucessores #'< :key #'avaliar-v2) max-depth jogador max-time alfa beta initial-time))
            )
          )
        )
  )
)

(defun alfabeta-max (sucessores max-depth jogador max-time alfa-atual beta-atual initial-time)
  (cond ((null sucessores) alfa-atual)
        ((>= alfa-atual beta-atual) beta-atual)
        (t (let ((alfa-novo (max alfa-atual (alfabeta (car sucessores) max-depth (trocar-jogador jogador) max-time alfa-atual beta-atual initial-time))))
            (if (= (no-profundidade (car sucessores)) 1)
              (guardar-solucao (car sucessores) alfa-novo)
            )
            (alfabeta-max (cdr sucessores) max-depth max-time jogador alfa-novo beta-atual initial-time)
          )
        )
  )
)

(defun alfabeta-min (sucessores max-depth jogador max-time alfa-atual beta-atual initial-time)
  (cond ((null sucessores) beta-atual)
        ((<= beta-atual alfa-atual) alfa-atual) 
        (t (let ((beta-novo (min beta-atual (alfabeta (car sucessores) max-depth (trocar-jogador jogador) max-time alfa-atual beta-atual initial-time))))
            (alfabeta-min (cdr sucessores) max-depth jogador max-time alfa-atual beta-novo initial-time)
          )
        )
  )
)